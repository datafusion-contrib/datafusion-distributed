// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DfRayStageReaderExecNode {
    /// schema of the stage we will consume
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<::datafusion_proto::protobuf::Schema>,
    /// properties of the stage we will consume
    #[prost(message, optional, tag = "2")]
    pub partitioning: ::core::option::Option<::datafusion_proto::protobuf::Partitioning>,
    /// stage to read from
    #[prost(uint64, tag = "3")]
    pub stage_id: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxRowsExecNode {
    #[prost(uint64, tag = "1")]
    pub max_rows: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartitionIsolatorExecNode {
    #[prost(uint64, tag = "2")]
    pub partition_count: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistributedAnalyzeExecNode {
    /// how much data to show
    #[prost(bool, tag = "1")]
    pub verbose: bool,
    /// if statistics should be displayed
    #[prost(bool, tag = "2")]
    pub show_statistics: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistributedAnalyzeRootExecNode {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistributedExplainExecNode {
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<::datafusion_proto::protobuf::Schema>,
    #[prost(string, tag = "2")]
    pub logical_plan: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub physical_plan: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub distributed_plan: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub distributed_stages: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DfRayExecNode {
    #[prost(oneof = "df_ray_exec_node::Payload", tags = "1, 2, 3, 4")]
    pub payload: ::core::option::Option<df_ray_exec_node::Payload>,
}
/// Nested message and enum types in `DFRayExecNode`.
pub mod df_ray_exec_node {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        StageReaderExec(super::DfRayStageReaderExecNode),
        #[prost(message, tag = "2")]
        MaxRowsExec(super::MaxRowsExecNode),
        #[prost(message, tag = "3")]
        IsolatorExec(super::PartitionIsolatorExecNode),
        /// DistributedAnalyzeRootExecNode distributed_analyze_root_exec = 5;
        #[prost(message, tag = "4")]
        DistributedAnalyzeExec(super::DistributedAnalyzeExecNode),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotatedTaskOutput {
    /// the output of the explain analyze
    #[prost(string, tag = "1")]
    pub plan: ::prost::alloc::string::String,
    /// the host who executed this stage
    #[prost(message, optional, tag = "2")]
    pub host: ::core::option::Option<Host>,
    /// the stage id that was executed
    #[prost(uint64, tag = "3")]
    pub stage_id: u64,
    /// the partitions that were executed by this stage
    #[prost(uint64, repeated, tag = "4")]
    pub partition_group: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotatedTaskOutputs {
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<AnnotatedTaskOutput>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlightDataMetadata {
    #[prost(message, optional, tag = "1")]
    pub annotated_task_outputs: ::core::option::Option<AnnotatedTaskOutputs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlightTicketData {
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub stage_id: u64,
    #[prost(uint64, tag = "3")]
    pub partition: u64,
    /// name of the requestor, useful in logs for debugging
    #[prost(string, tag = "4")]
    pub requestor_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TicketStatementData {
    /// identity of the query we want to consume
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    /// the stage id of the final stage
    #[prost(uint64, tag = "2")]
    pub stage_id: u64,
    /// host holding the final stage, the root of the query plan
    #[prost(message, optional, tag = "3")]
    pub stage_addrs: ::core::option::Option<StageAddrs>,
    /// the schema of the final stage
    #[prost(message, optional, tag = "4")]
    pub schema: ::core::option::Option<::datafusion_proto::protobuf::Schema>,
    /// For EXPLAIN queries, store the explain plan data directly
    #[prost(message, optional, tag = "5")]
    pub explain_data: ::core::option::Option<DistributedExplainExecNode>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Host {
    #[prost(string, tag = "1")]
    pub addr: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hosts {
    #[prost(message, repeated, tag = "1")]
    pub hosts: ::prost::alloc::vec::Vec<Host>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionAddrs {
    #[prost(map = "uint64, message", tag = "1")]
    pub partition_addrs: ::std::collections::HashMap<u64, Hosts>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StageAddrs {
    /// map of stage id to stage address
    #[prost(map = "uint64, message", tag = "1")]
    pub stage_addrs: ::std::collections::HashMap<u64, PartitionAddrs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StageData {
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub stage_id: u64,
    #[prost(uint64, repeated, tag = "3")]
    pub partition_group: ::prost::alloc::vec::Vec<u64>,
    #[prost(bytes = "vec", tag = "4")]
    pub plan_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, repeated, tag = "5")]
    pub child_stage_ids: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, optional, tag = "6")]
    pub stage_addrs: ::core::option::Option<StageAddrs>,
    #[prost(uint64, tag = "7")]
    pub num_output_partitions: u64,
    #[prost(bool, tag = "8")]
    pub full_partitions: bool,
    #[prost(message, optional, tag = "9")]
    pub assigned_addr: ::core::option::Option<Host>,
}
