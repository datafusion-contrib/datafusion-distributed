// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DfRayStageReaderExecNode {
    /// schema of the stage we will consume
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<::datafusion_proto::protobuf::Schema>,
    /// properties of the stage we will consume
    #[prost(message, optional, tag = "2")]
    pub partitioning: ::core::option::Option<::datafusion_proto::protobuf::Partitioning>,
    /// stage to read from
    #[prost(uint64, tag = "3")]
    pub stage_id: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxRowsExecNode {
    #[prost(uint64, tag = "1")]
    pub max_rows: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartitionIsolatorExecNode {
    #[prost(float, tag = "1")]
    pub dummy: f32,
    #[prost(uint64, tag = "2")]
    pub partition_count: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NumpangScanExecNode {
    #[prost(message, optional, tag = "1")]
    pub base_conf: ::core::option::Option<
        ::datafusion_proto::protobuf::FileScanExecConf,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContextScanExecNode {
    #[prost(message, optional, tag = "1")]
    pub base_conf: ::core::option::Option<
        ::datafusion_proto::protobuf::FileScanExecConf,
    >,
    #[prost(message, repeated, tag = "2")]
    pub filters: ::prost::alloc::vec::Vec<::datafusion_proto::protobuf::LogicalExprNode>,
    #[prost(message, optional, tag = "3")]
    pub schema: ::core::option::Option<::datafusion_proto::protobuf::Schema>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DfRayExecNode {
    #[prost(oneof = "df_ray_exec_node::Payload", tags = "1, 2, 3, 4, 5")]
    pub payload: ::core::option::Option<df_ray_exec_node::Payload>,
}
/// Nested message and enum types in `DFRayExecNode`.
pub mod df_ray_exec_node {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        StageReaderExec(super::DfRayStageReaderExecNode),
        #[prost(message, tag = "2")]
        MaxRowsExec(super::MaxRowsExecNode),
        #[prost(message, tag = "3")]
        IsolatorExec(super::PartitionIsolatorExecNode),
        #[prost(message, tag = "4")]
        NumpangExec(super::NumpangScanExecNode),
        #[prost(message, tag = "5")]
        ContextExec(super::ContextScanExecNode),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlightTicketData {
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub stage_id: u64,
    #[prost(uint64, tag = "3")]
    pub partition: u64,
    /// name of the requestor, useful in logs for debugging
    #[prost(string, tag = "4")]
    pub requestor_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TicketStatementData {
    /// identity of the query we want to consume
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    /// the stage id of the final stage
    #[prost(uint64, tag = "2")]
    pub stage_id: u64,
    /// host holding the final stage, the root of the query plan
    #[prost(message, optional, tag = "3")]
    pub stage_addrs: ::core::option::Option<StageAddrs>,
    /// the schema of the final stage
    #[prost(message, optional, tag = "4")]
    pub schema: ::core::option::Option<::datafusion_proto::protobuf::Schema>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Host {
    #[prost(string, tag = "1")]
    pub addr: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hosts {
    #[prost(message, repeated, tag = "1")]
    pub hosts: ::prost::alloc::vec::Vec<Host>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionAddrs {
    #[prost(map = "uint64, message", tag = "1")]
    pub partition_addrs: ::std::collections::HashMap<u64, Hosts>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StageAddrs {
    /// map of stage id to stage address
    #[prost(map = "uint64, message", tag = "1")]
    pub stage_addrs: ::std::collections::HashMap<u64, PartitionAddrs>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StageData {
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub stage_id: u64,
    #[prost(uint64, repeated, tag = "3")]
    pub partition_group: ::prost::alloc::vec::Vec<u64>,
    #[prost(bytes = "vec", tag = "4")]
    pub plan_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, repeated, tag = "5")]
    pub child_stage_ids: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, optional, tag = "6")]
    pub stage_addrs: ::core::option::Option<StageAddrs>,
    #[prost(uint64, tag = "7")]
    pub num_output_partitions: u64,
    #[prost(bool, tag = "8")]
    pub full_partitions: bool,
    #[prost(message, optional, tag = "9")]
    pub assigned_addr: ::core::option::Option<Host>,
}
